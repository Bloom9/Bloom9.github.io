<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统实验一:进程调度</title>
      <link href="2021/06/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
      <url>2021/06/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="进程调度实验"><a href="#进程调度实验" class="headerlink" title="进程调度实验"></a>进程调度实验</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>&#160; &#160; &#160; &#160;多道程序设计中，经常是若干个进程同时处于就绪状态，必须依照某种策略来决定那个进程优先占有处理机。因而引起进程调度。本实验模拟在单处理机情况下的处理机调度问题，加深对进程调度的理解。</p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol><li>优先权法-动态优先权</li><li>轮转法</li></ol><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://github.com/Daydream0929/Image/blob/main/shiyan1a.png?raw=true" alt="实验1a"><br><img src="https://github.com/Daydream0929/Image/blob/main/shiyan1b.png?raw=true" alt="实验1b"></p><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><ol><li>产生的各种随机数的取值范围加以限制，如所需的CPU时间限制在1~20之间。</li><li>进程数n不要太大通常取4~8个</li><li>使用动态数据结构</li><li>独立编程</li><li>两种调度算法</li></ol><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://github.com/Daydream0929/Image/blob/main/priority.png?raw=true" alt="priority"><br><img src="https://github.com/Daydream0929/Image/blob/main/timepiece.png?raw=true" alt="timepiece"></p><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><pre class="language-none"><code class="language-none">#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;int n;const int N &#x3D; 10;struct PCB &#123;string name;int time;int priority;int status;int runtime;int lefttime;&#125;;struct cmp &#123;bool operator()(PCB a, PCB b) &#123;if (a.priority &#x3D;&#x3D; b.priority) &#123;return a.time &gt; b.time;&#125;return a.priority &lt; b.priority;&#125;&#125;;&#x2F;&#x2F;动态优先权队列priority_queue&lt;PCB, vector&lt;PCB&gt;, cmp&gt; q1;   &#x2F;&#x2F;readyqueue&lt;PCB&gt; q3;  &#x2F;&#x2F;finishvoid init_priority() &#123;PCB t;for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;t.name &#x3D; &#39;a&#39; + i - 1;t.priority &#x3D; (rand() % 20) + 50;t.time &#x3D; (rand() % 20) + 1;t.status &#x3D; -1;t.lefttime &#x3D; t.time;t.runtime &#x3D; 0;q1.push(t);&#125;&#125;void print_priority(priority_queue&lt;PCB, vector&lt;PCB&gt;, cmp&gt; q) &#123;while (!q.empty()) &#123;PCB t &#x3D; q.top();cout &lt;&lt; t.name &lt;&lt; &#39;\t&#39; &lt;&lt; t.time &lt;&lt; &#39;\t&#39; &lt;&lt; t.priority &lt;&lt; &#39;\t&#39; &lt;&lt; t.status &lt;&lt; &#39;\t&#39; &lt;&lt; t.runtime + 1 &lt;&lt; &#39;\t&#39; &lt;&lt; &#39;\t&#39; &lt;&lt; t.lefttime - 1 &lt;&lt; endl;q.pop();&#125;&#125;void print_finish1(queue&lt;PCB&gt; q) &#123;cout &lt;&lt; &quot;完成队列过程如下: &quot; &lt;&lt; endl;cout &lt;&lt; &quot;名字&quot; &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;时间&quot; &lt;&lt; &#39;\t&#39; &lt;&lt; &quot; 优先级&quot; &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;状态&quot; &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;运行时间&quot; &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;剩余时间&quot; &lt;&lt; endl;while (!q.empty()) &#123;PCB t &#x3D; q.front();cout &lt;&lt; t.name &lt;&lt; &#39;\t&#39; &lt;&lt; t.time &lt;&lt; &#39;\t&#39; &lt;&lt; t.priority &lt;&lt; &#39;\t&#39; &lt;&lt; t.status &lt;&lt; &#39;\t&#39; &lt;&lt; t.runtime &lt;&lt; &#39;\t&#39; &lt;&lt; &#39;\t&#39; &lt;&lt; t.lefttime &lt;&lt; endl;q.pop();&#125;&#125;void run_priority() &#123;while (!q1.empty()) &#123;print_priority(q1);PCB t &#x3D; q1.top();t.priority -&#x3D; 3;t.lefttime -&#x3D; 1;t.runtime +&#x3D; 1;t.status &#x3D; 0;if (t.lefttime &lt;&#x3D; 0) &#123;t.status &#x3D; 1;q3.push(t);  &#x2F;&#x2F;插入到finish队列q1.pop();&#125;else &#123;t.status &#x3D; -1;q1.pop();q1.push(t);     &#x2F;&#x2F;插入到就绪队列&#125;&#125;cout &lt;&lt; &quot;所有进程均已执行完毕!&quot; &lt;&lt; endl;cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;&#125;&#x2F;&#x2F;时间片轮转法队列queue&lt;PCB&gt; q2;void init_timeturn() &#123;PCB t;for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;t.name &#x3D; &#39;a&#39; + i - 1;t.time &#x3D; (rand() % 20) + 1;t.status &#x3D; -1;t.lefttime &#x3D; t.time;t.runtime &#x3D; 0;q2.push(t);&#125;&#125;void print_timeturn(queue&lt;PCB&gt; q) &#123;while (!q.empty()) &#123;PCB t &#x3D; q.front();cout &lt;&lt; t.name &lt;&lt; &#39;\t&#39; &lt;&lt; t.time &lt;&lt; &#39;\t&#39; &lt;&lt; t.status &lt;&lt; &#39;\t&#39; &lt;&lt; t.runtime + 1 &lt;&lt; &#39;\t&#39; &lt;&lt; &#39;\t&#39; &lt;&lt; t.lefttime - 1 &lt;&lt; endl;q.pop();&#125;&#125;void print_finish2(queue&lt;PCB&gt; q) &#123;cout &lt;&lt; &quot;完成队列过程如下: &quot; &lt;&lt; endl;cout &lt;&lt; &quot;名字&quot; &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;时间&quot; &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;状态&quot; &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;运行时间&quot; &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;剩余时间&quot; &lt;&lt; endl;while (!q.empty()) &#123;PCB t &#x3D; q.front();cout &lt;&lt; t.name &lt;&lt; &#39;\t&#39; &lt;&lt; t.time &lt;&lt; &#39;\t&#39; &lt;&lt; t.status &lt;&lt; &#39;\t&#39; &lt;&lt; t.runtime &lt;&lt; &#39;\t&#39; &lt;&lt; &#39;\t&#39; &lt;&lt; t.lefttime &lt;&lt; endl;q.pop();&#125;&#125;void run_timeturn() &#123;while (!q2.empty()) &#123;print_timeturn(q2);PCB t &#x3D; q2.front();t.runtime +&#x3D; 1;t.lefttime -&#x3D; 1;t.status &#x3D; 0;if (t.lefttime &lt;&#x3D; 0) &#123;t.status &#x3D; 1;q3.push(t);q2.pop();&#125;else &#123;t.status &#x3D; -1;q2.push(t);q2.pop();&#125;&#125;cout &lt;&lt; &quot;所有进程均已执行完毕!&quot; &lt;&lt; endl;cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;&#125;int main() &#123;int c;cout &lt;&lt; &quot;选择调度算法 : 1.优先级调度 2.时间片轮转 &quot; &lt;&lt; endl;cin &gt;&gt; c;cout &lt;&lt; &quot;输入进程个数 : &quot; &lt;&lt; endl;cin &gt;&gt; n;cout &lt;&lt; endl;cout &lt;&lt; &quot;状态栏 ‘-1’代表就绪, ‘1’代表完成&quot; &lt;&lt; endl &lt;&lt; endl;if (c &#x3D;&#x3D; 1) &#123;init_priority();cout &lt;&lt; &quot;就绪队列过程如下: &quot; &lt;&lt; endl;cout &lt;&lt; &quot;名字&quot; &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;时间&quot; &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;优先级&quot; &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;状态&quot; &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;运行时间&quot; &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;剩余时间&quot; &lt;&lt; endl;run_priority();print_finish1(q3);&#125;else if (c &#x3D;&#x3D; 2) &#123;init_timeturn();cout &lt;&lt; &quot;就绪队列过程如下: &quot; &lt;&lt; endl;cout &lt;&lt; &quot;名字&quot; &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;时间&quot; &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;状态&quot; &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;运行时间&quot; &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;剩余时间&quot; &lt;&lt; endl;run_timeturn();print_finish2(q3);&#125;else &#123;cout &lt;&lt; &quot;输入错误 ,自动退出 ! : &quot; &lt;&lt; endl;&#125;return 0;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Acwing第一场周赛</title>
      <link href="2021/05/29/Acwing%E7%AC%AC%E4%B8%80%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
      <url>2021/05/29/Acwing%E7%AC%AC%E4%B8%80%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="3577-选择数字"><a href="#3577-选择数字" class="headerlink" title="3577.选择数字"></a>3577.选择数字</h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个整数数组 A，其包含 n 个正整数 a1,a2,…,an 以及一个整数数组 B，其包含 m 个正整数 b1,b2,…,bm。</p><p>请从数组 A 中挑选一个元素 a 并从数组 B 中挑选一个元素 b，使得 a+b 既不包含于 A 也不包含于 B。</p><p>例如，如果 A=[2,1,7] 而 B=[1,3,4]，则可以从 A 中选取 1，从 B 中选取 4，这样得到的数字 1+4=5 既不在 A 中，也不在 B 中。</p><p>但是，我们不能从 A 中选取 2，从 B 中选取 1，因为得到的数字 2+1=3 包含于 B。</p><p>可以证明这样的数对一定存在，如果答案不唯一则输出任意合理答案均可。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n。</p><p>第二行包含 n 个整数 a1,…,an。</p><p>第三行包含整数 m。</p><p>第四行包含 m 个整数 b1,…,bm。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，输出 a 和 b，中间用空格隔开。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于 30% 的数据，1≤n,m≤10<br>对于 100% 的数据，1≤n,m≤100,1≤ai,bi≤200</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><p>1</p><p>20</p><p>2</p><p>10 20</p><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><p>20 20</p><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><p>3</p><p>3 2 2</p><p>5</p><p>1 5 7 7 9</p><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><p>3 1</p><h4 id="输入样例3："><a href="#输入样例3：" class="headerlink" title="输入样例3："></a>输入样例3：</h4><p>4</p><p>1 3 5 7</p><p>4</p><p>7 5 3 1</p><h4 id="输出样例3："><a href="#输出样例3：" class="headerlink" title="输出样例3："></a>输出样例3：</h4><p>1 1</p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>这道题数据范围比较小暴力搜索就可以<br>我们这里用个小技巧<br>两次遍历分别找出两个数组A中的最大值x和数组B中的最大值y<br>那么x+y一定即不再A中也不在B中<br>直接输出就可以了</p><h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><pre class="language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 210;int n,m;int main()&#123;    cin&gt;&gt;n;    int x&#x3D;0,y&#x3D;0;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;        int a;        cin&gt;&gt;a;        x&#x3D;max(x,a);    &#125;    cin&gt;&gt;m;    for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;        int b;        cin&gt;&gt;b;        y&#x3D;max(b,y);    &#125;    cout&lt;&lt;x&lt;&lt;&#39; &#39;&lt;&lt;y&lt;&lt;endl;    return 0;    &#125;</code></pre><h2 id="3578-最大中位数"><a href="#3578-最大中位数" class="headerlink" title="3578.最大中位数"></a>3578.最大中位数</h2><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个由 n 个整数组成的数组 a，其中 n 为奇数。</p><p>你可以对其进行以下操作：</p><p>选择数组中的一个元素（例如 ai），将其增加 1（即，将其替换为 ai+1）。<br>你最多可以进行 k 次操作，并希望该数组的中位数能够尽可能大。</p><p>奇数长度的数组的中位数是数组以非降序排序后的中间元素。</p><p>例如，数组 [1,5,2,3,5] 的中位数为 3</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 k。</p><p>第二行包含 n 个整数 a1,a2,…,an。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示通过操作可能得到的最大中位数。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于 30% 的数据，1≤n≤5。<br>对于 100% 的数据，1≤n≤2×105，1≤k≤109，1≤ai≤109。</p><h4 id="输入样例1：-1"><a href="#输入样例1：-1" class="headerlink" title="输入样例1："></a>输入样例1：</h4><p>3 2</p><p>1 3 5</p><h4 id="输出样例1：-1"><a href="#输出样例1：-1" class="headerlink" title="输出样例1："></a>输出样例1：</h4><p>5</p><h4 id="输入样例2：-1"><a href="#输入样例2：-1" class="headerlink" title="输入样例2："></a>输入样例2：</h4><p>5 5</p><p>1 2 1 1 1</p><h4 id="输出样例2：-1"><a href="#输出样例2：-1" class="headerlink" title="输出样例2："></a>输出样例2：</h4><p>3</p><h4 id="输入样例3：-1"><a href="#输入样例3：-1" class="headerlink" title="输入样例3："></a>输入样例3：</h4><p>7 7</p><p>4 1 2 4 3 4 4</p><h4 id="输出样例3：-1"><a href="#输出样例3：-1" class="headerlink" title="输出样例3："></a>输出样例3：</h4><p>5</p><hr><h4 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h4><h4 id="贪心-左右指针-O-nlog-n"><a href="#贪心-左右指针-O-nlog-n" class="headerlink" title="(贪心+左右指针)  $O(nlog n)$"></a>(贪心+左右指针)  $O(nlog n)$</h4><p>这道题首先我们将整个数组<br>然后我们定义一个左右指针l,r<br>定义n=数组大小-1</p><p>左指针l指向中位数所在下标<br>右指针r指向中位数右边(包括中位数本身)最后一个等于中位数的下标 (l&lt;=r&lt;=n) </p><p>这样我们的左右指针就是一个区间</p><p>每次循环我们都把区间内所有的数 +1 这样我们的中位数就 +1 同时 k要减去 r-l+1 </p><p>当 k==0 或者 k&lt;r-l+1 (不够区间内所有值都+1) 的时候循环停止 此时的中位数就是我们要求的中位数</p><h4 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><pre class="language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 1e6+10;typedef long long LL;int n,k;int a[N];int seekR(int q[],int r)&#123;  &#x2F;&#x2F;寻找右端点    int res&#x3D;r;    int flag&#x3D;0;    for(int i&#x3D;r;i&lt;&#x3D;n;i++)&#123;        if(q[r]&#x3D;&#x3D;q[i])&#123;            continue;        &#125;        else&#123;            flag&#x3D;1;            res&#x3D;i-1;            break;        &#125;    &#125;    if(flag&#x3D;&#x3D;0)&#123;        res&#x3D;n;    &#125;    return res;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;k;    for(int i&#x3D;1;i&lt;&#x3D;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);    if(n&#x3D;&#x3D;1)&#123;        cout&lt;&lt;k+a[1]&lt;&lt;endl;        return 0;    &#125;    sort(a+1,a+n+1);            int l&#x3D;(n&#x2F;2)+1;    int r&#x3D;seekR(a,l);    int num&#x3D;a[l];        while(k &amp;&amp; k&gt;&#x3D;r-l+1)&#123;        num++;        k-&#x3D;r-l+1;        a[r]&#x3D;num;        r&#x3D;seekR(a,r);    &#125;    cout&lt;&lt;num&lt;&lt;endl;     return 0;&#125;</code></pre><hr><h4 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h4><h4 id="二分-O-nlong-n"><a href="#二分-O-nlong-n" class="headerlink" title="(二分)  $O(nlong n)$"></a>(二分)  $O(nlong n)$</h4><p>当时做题的时候并没有想到二分<br>这种方法是参考别人的</p><p>我们每次从 1 到 2e9 中二分查找答案<br>这里解释一下右端点为什么是 2e9 ：<br>因为题目给出的范围 1&lt;=k&lt;=1e9,1&lt;=w[i]&lt;=1e9 如果说k==1e9 n==1 w[0]== 1e9 的时候<br>要找的答案就是1e9+1e9 也就是我们右端点的最大值</p><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><p><a href="https://www.acwing.com/activity/content/code/content/1300036/">https://www.acwing.com/activity/content/code/content/1300036/</a></p><h4 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><pre class="language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;typedef long long LL;using namespace std;const int N &#x3D; 2e5+10;int n,k;int w[N];bool check(int mid)&#123;    LL res&#x3D;0;    for(int i&#x3D;n&#x2F;2;i&lt;n;i++)&#123;        if(w[i]&lt;mid)            res+&#x3D;mid-w[i];    &#125;    return res&lt;&#x3D;k;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;k;    for(int i&#x3D;0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;w[i]);    sort(w,w+n);    int l&#x3D;0,r&#x3D;2e9;    while(l&lt;r)&#123;        int mid&#x3D;(LL)l+r+1&gt;&gt;1;        if(check(mid)) l&#x3D;mid;        else r&#x3D;mid-1;    &#125;    printf(&quot;%d\n&quot;,r);    return 0;&#125;</code></pre><h2 id="3579-移动数字"><a href="#3579-移动数字" class="headerlink" title="3579.移动数字"></a>3579.移动数字</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>将 1∼n 按顺序排成一排，构成一个数列。</p><p>数字 i 刚好位于位置 i。</p><p>再给定一个长度为 n 的位置序列 p1,p2,…,pn，它是 1∼n 的一种排列。</p><p>接下来，我们会重复不断地对数列进行如下操作：</p><p>重新排列数列中每个数的位置，将位于位置 i 的数移动至位置 pi。（如果 i=pi 则该数仍移动至位置 i）。<br>每次操作开始时，所有数的移动同时进行，操作结束后，数列将变为一个新的 1∼n 的排列。<br>例如，当 n=6 并且 p=[4,6,1,3,5,2] 时，第一次操作后，数字 1 将移动至位置 4，数字 2 将移动至位置 6，以此类推；第二次操作后，数字 1 将移动至位置 3，数字 2 将移动至位置 2，以此类推。</p><p>你的任务是确定从 1 到 n 的每个数字 i，经过多少次操作后，第一次重新回到位置 i。</p><p>例如，考虑 p=[5,1,2,4,3]，数字 1 的移动轨迹如下：</p><p>第一次操作后，到达位置 5。<br>第二次操作后，到达位置 3。<br>第三次操作后，到达位置 2。<br>第四次操作后，回到位置 1。<br>所以，经过四次操作后，数字 1 第一次回到位置 1。</p><p>值得一提的是，数字 4 经过一次操作后就回到了位置 4.</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 T，表示共有 T 组测试数据。</p><p>每组数据第一行包含整数 n。</p><p>第二行包含 n 个整数 p1,…,pn。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>每组数据输出一行结果，包含 n 个整数，其中第 i 个整数表示数字 i 第一次回到位置 i 所经过的操作次数。</p><p>整数之间用单个空格隔开。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于 30% 的数据，1≤T≤10，1≤n≤10。<br>对于 100% 的数据，1≤T≤1000，1≤n≤2×105，1≤pi≤n。<br>保证 p1∼pn 是 1∼n 的一种排列。<br>保证 ∑n≤2×105（一个输入中的 T 个 n 相加之和不超过 2×105）。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><p>6</p><p>5</p><p>1 2 3 4 5</p><p>3</p><p>2 3 1</p><p>6</p><p>4 6 2 1 5 3</p><p>1</p><p>1</p><p>4</p><p>3 4 1 2</p><p>5</p><p>5 1 2 4 3</p><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><p>1 1 1 1 1 </p><p>3 3 3 </p><p>2 3 3 2 1 3 </p><p>1 </p><p>2 2 2 2 </p><p>4 4 4 1 4 </p><hr><h3 id="算法1-1"><a href="#算法1-1" class="headerlink" title="算法1"></a>算法1</h3><h5 id="并查集求连通块个数"><a href="#并查集求连通块个数" class="headerlink" title="(并查集求连通块个数)"></a>(并查集求连通块个数)</h5><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://www.acwing.com/activity/content/code/content/1300090/">https://www.acwing.com/activity/content/code/content/1300090/</a></p><p><a href="https://www.acwing.com/problem/content/839/">https://www.acwing.com/problem/content/839/</a></p><h4 id="C-代码-3"><a href="#C-代码-3" class="headerlink" title="C++ 代码"></a>C++ 代码</h4><pre class="language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 200010;int n,T;int p[N],s[N];int find(int x)&#123;  &#x2F;&#x2F;并查集+路径压缩    if(p[x]!&#x3D;x) p[x]&#x3D;find(p[x]);    return p[x];&#125;int main()&#123;    cin&gt;&gt;T;    while(T--)&#123;        cin&gt;&gt;n;        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;  &#x2F;&#x2F;初始化            p[i]&#x3D;i;            s[i]&#x3D;1;        &#125;        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;            int j;            cin&gt;&gt;j;            if(find(i)!&#x3D;find(j))&#123;                s[find(j)]+&#x3D;s[find(i)];                p[find(i)]&#x3D;find(j);            &#125;        &#125;        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;            printf(&quot;%d &quot;,s[find(i)]);        &#125;        puts(&quot; &quot;);    &#125;    return 0;&#125;</code></pre><hr>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
